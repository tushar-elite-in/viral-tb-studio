import uvicorn
import os
import sys
import uuid
import asyncio
from fastapi import FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from pydantic import BaseModel
from dotenv import load_dotenv
from google.genai import types

# Load environment variables from .env file in the same directory
current_dir = os.path.dirname(os.path.abspath(__file__))
load_dotenv(os.path.join(current_dir, ".env"))
static_dir = os.path.join(current_dir, "static")

# Add the current directory to sys.path to ensure we can import agent
sys.path.append(current_dir)

from agent import runner

app = FastAPI()

class VideoIdea(BaseModel):
    idea: str

@app.get("/generate")
async def serve_generator_page():
    return FileResponse(os.path.join(static_dir, "generate.html"))

@app.post("/api/generate")
async def generate_content(request: VideoIdea):
    try:
        print(f"Processing idea: {request.idea}")
        
        async def process_agent():
            session_id = str(uuid.uuid4())
            user_id = "user"
            
            # Create the session first
            await runner.session_service.create_session(
                app_name=runner.app_name,
                user_id=user_id,
                session_id=session_id
            )
            
            # Create the user message properly using google.genai.types
            message = types.UserContent(parts=[types.Part(text=request.idea)])
            
            output = None
            
            # Iterate over events generated by the runner
            async for event in runner.run_async(
                user_id=user_id, 
                session_id=session_id, 
                new_message=message
            ):
                # Check for state updates containing our desired output key
                if event.actions and event.actions.state_delta:
                    if "executive_summary" in event.actions.state_delta:
                        output = event.actions.state_delta["executive_summary"]
                        # We could break here, but it's safer to let the agent finish 
                        # in case there are cleanup tasks or other events.
            return output

        # Set a 3-minute timeout for the generation
        final_output = await asyncio.wait_for(process_agent(), timeout=180.0)
                    
        if not final_output:
             # Fallback: check if we have any model output in the last event content if state was missed
             # But strictly following agent.py, executive_summary is the key.
             final_output = "No strategy generated. Please check logs/configuration."

        return {"result": final_output}

    except asyncio.TimeoutError:
        print("Generation timed out.")
        raise HTTPException(status_code=504, detail="Request timed out. The agent took too long to respond.")

    except Exception as e:
        print(f"Error during generation: {e}")
        # Log the full error for debugging
        import traceback
        traceback.print_exc()
        
        error_msg = str(e)
        
        # Handle ExceptionGroup (Python 3.11+) to get the actual error
        if hasattr(e, 'exceptions'):
            # Join messages or take the first one
            error_msg = "; ".join([str(ex) for ex in e.exceptions])
            
        if "429" in error_msg or "ResourceExhausted" in error_msg or "quota" in error_msg.lower():
            raise HTTPException(
                status_code=429, 
                detail="API Quota Exceeded. Please wait a moment and try again. (Google Gemini API limit reached)"
            )
            
        raise HTTPException(status_code=500, detail=error_msg)

# Mount the static directory to serve the frontend
static_dir = os.path.join(current_dir, "static")
if not os.path.exists(static_dir):
    os.makedirs(static_dir)

app.mount("/", StaticFiles(directory=static_dir, html=True), name="static")

if __name__ == "__main__":
    print("Starting server at http://127.0.0.1:8000")
    uvicorn.run(app, host="127.0.0.1", port=8000)
